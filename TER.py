# -*- coding: utf-8 -*-
"""TER.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SkCK3req8uGu6WxrtU0BU21u75YeFiA3
"""

import pandas as pd

events = pd.read_table("Log.log",sep = "|")
events.head()

events.columns

events['ServiceID'].values.tolist()

QOS = pd.read_table('QOS.txt',sep = '|')
QOS.head()
#c = la condition -> Ex : BadRC si RC < 3ms <-> < 3

#Récupérer les concepts et les conditions associées
'''c = QOS['Element1'].values.tolist()
c[0].split(':')'''
#QOS.columns.to_list()
df_colonnes = QOS.columns.to_list()
data = []
for elem in df_colonnes:
  data_elem = []
  for i in range(len(QOS[elem].values.tolist())) :
    data_elem.append(QOS[elem].values.tolist()[i].split(':'))
  data.append(data_elem)
data

#ACTUEL 01/05/2024
#Remplacer les valeurs quantitative par les valeurs qualitative
#Ca va redonner la table Log mais pour les elems on aura des val qualitativ a la place
#chercher cb de colonne Elements dans le log
nombre = len(events.columns.to_list())-3
events_list_elems = events.columns.to_list()[3:] #on recup une liste qu'avec les éléments dedans
events_copied = events.copy()
nb_elem = 0 #variable simule la colonne sur laquelle on est de g à d
affecter = False
for elem in events_list_elems : #pour chaque colonne éléments
  print("FOR 1")
  list_concepts = [] #les concepts qu'on va ajouter à chaque colonne (remplacera les val numérique)
  list_valeur_numerique = []
  list_valeur_egalite = [] #pour stocker les < <= > >= =
  for i in range(len(data[nb_elem])) :
    print("FOR 3")
    tmp = data[nb_elem][i][1].split(" ") #donc on split la condition Ex : c = "< 3"
    print(tmp)
    #récupère la valeur quantitative Ex : le 3 ici
    list_valeur_numerique.append(tmp[1])
    list_valeur_egalite.append(tmp[0])
  for i in range(len(data[nb_elem])):
    print("FOR 4")
    Affecter = False
    #print(events[elem].values.tolist()[i])
    #print(data[nb_elem][i][0])
    #print(len(list_valeur_numerique))
    print(list_valeur_egalite)
    if list_valeur_egalite[i] == "=" : #on regarde quel symbol c'est puis selon le symbol en question on va chercher les lignes d'la colonne qui respecte ce symbol (condition)
      print("IF 1")
      for j in range(len(events[elem].values.tolist())): #la boucle pour comparer chaque ligne de la colonne selon le symbol d'égalité et la valeur associé
        print(events[elem].values.tolist()[j])
        print(float(list_valeur_numerique[i]))
        if events[elem].values.tolist()[j] == float(list_valeur_numerique[i]) :
          Affecter = True
          print("IF 1")
          list_concepts.insert(j,(data[nb_elem][i][0]))
    elif list_valeur_egalite[i] == "<=" :
      print("IF 2")
      for j in range(len(events[elem].values.tolist())): #la boucle pour comparer chaque ligne de la colonne selon le symbol d'égalité et la valeur associé
        print(events[elem].values.tolist()[j])
        print(float(list_valeur_numerique[i]))
        if events[elem].values.tolist()[j] <= float(list_valeur_numerique[i]) :
          Affecter = True
          print("IF 2")
          list_concepts.insert(j,(data[nb_elem][i][0]))
    elif list_valeur_egalite[i] == ">=" :
      print("IF 3")
      for j in range(len(events[elem].values.tolist())): #la boucle pour comparer chaque ligne de la colonne selon le symbol d'égalité et la valeur associé
        print(events[elem].values.tolist()[j])
        print(float(list_valeur_numerique[i]))
        if events[elem].values.tolist()[j] >= float(list_valeur_numerique[i]) :
          Affecter = True
          print("IF 3")
          list_concepts.insert(j,(data[nb_elem][i][0]))
    elif list_valeur_egalite[i] == "<" :
      print("IF 4")
      for j in range(len(events[elem].values.tolist())): #la boucle pour comparer chaque ligne de la colonne selon le symbol d'égalité et la valeur associé
        print(events[elem].values.tolist()[j])
        print(float(list_valeur_numerique[i]))
        if events[elem].values.tolist()[j] < float(list_valeur_numerique[i]) :
          Affecter = True
          print("IF 4")
          list_concepts.insert(j,(data[nb_elem][i][0]))
    elif list_valeur_egalite[i] == ">" :
      print("IF 5")
      for j in range(len(events[elem].values.tolist())) :#la boucle pour comparer chaque ligne de la colonne selon le symbol d'égalité et la valeur associé
        print(events[elem].values.tolist()[j])
        print(float(list_valeur_numerique[i]))
        if events[elem].values.tolist()[j] > float(list_valeur_numerique[i]) :
          Affecter = True
          list_concepts.insert(j,(data[nb_elem][i][0]))
    if not Affecter :
     list_concepts.insert(i-1,'NaN') #NaN quand aucune des conditions d'égalité n'a match mais normalement y'en aura pas si les fichiers inputs sont bien faits
  events_copied[elem] = list_concepts #remplace les éléments numérique en élément qualitative
  print(list_concepts)
  nb_elem += 1
events_copied.head()

#data[0]
data[nb_elem]

#Trouver les proba associé à chaque concept et sortir un fichier avec Concept(proba(c))
#proba = nb de fois où le concepts apparait pour le service donné / le nb de fois où le service donnée est exécuté

#crée une liste qui énumere tous les concepts
concepts = []
for elem in events_list_elems:
  for i in range(len(events_copied[elem].values.tolist())) :
    if events_copied[elem].values.tolist()[i] not in concepts :
      concepts.append(events_copied[elem].values.tolist()[i])

#crée une liste qui énumere tous les services
services = list(set(events['ServiceID'].values.tolist()))

df = events_copied.iloc[:,2:]
lignes = df.values.tolist()

def proba(concept,serviceID,lignes): #on va parcourir ligne par ligne du df, regarder l'association du concept avec le serviceID
  #compter le nombre de fois où serviceID apparait
  compteur_serviceID = 0
  compteur_concept = 0
  for line in lignes :
    if serviceID in line :
      compteur_serviceID +=1
      if concept in line :
        compteur_concept +=1
  return compteur_concept/compteur_serviceID

#proba("Superieur1","S1",lignes)

#Avoir un dictionnaire avec {Concept : [Service,proba]}

dico = dict()
for concept in concepts :
  for service in services :
    if proba(concept,service,lignes) != 0 : #donc qu'il y a pas d'association entre serviceID et le concept
    #faut vérifier si le concept n'est pas déjà dans le dict pcq on peut pas avoir 2 fois la mm clé
      if concept not in dico.keys() : 
        dico[concept] = [service,proba(concept,service,lignes)]
      else :
        dico[concept].append(service)
        dico[concept].append(proba(concept,service,lignes))
#dico

with open("output.txt","w") as f :
  for key in dico :
    f.write(key+"(")
    word = ""
    for i in range(len(dico[key])) :
      word += str(dico[key][i])+","
    word = word[:-1] + ")"
    f.write(f"{word}\n")

with open("output.txt","r") as f :
  for line in f.readlines() :
    print(line)

